---
tags:
  - 计算机语言
created: 2025-12-17
---
---
## 核心要点



---
## 运算符和语句
- 主要知识点
	- 右结合运算符
		-  赋值类：`=` `+=` `-=` `*=` `/=` 等
		- 单目运算符：`++` `--` `!` `~` `+` `-` ``* & (type)
		- 三目运算符：`?:`
			- exp1?exp2：exp3;  通过判断exp1的真假，得出exp2还是exp3的值
		- 函数调用：`()`
	- 除了单目、赋值、三目，其他基本上是左结合
	- ++和* 运算符的等级相同，右结合原则
	- sizeof （type） 计算操作数的类型长度 单位字节
	- sizeof（arr[]）计算数组内元素的大小 
	- 计算数组的字符元素个数=sizeof（arr)/sizeof（arr[]）
	- 括号表达式
		- **从左到右依次计算**每个子表达式；
		- **整个表达式的值是最后一个子表达式（exprN）的值**；
		- 括号表达式返回值为0/1
	- include<stido.h>
		- scanf 中的 %d 格式说明符在读取数字前会跳过任何空白字符
		- （包括空格、制表符\t、换行符 \n 等）
		- getchar 读取一个字符 （/n）
			- int c，while ((c = getchar()) != '\n' && c != EOF);  // 清空一行
			- int c;while ((c = getchar()) != '\n' && c != EOF) {putchar(c);  // 或处理字符符
			- EOF为整型变量-1
		- char * fgets(char * str, int size, FILE * stream);
			-  `str`：存放读入内容的字符数组（缓冲区）
			- `size`：最多读 `size - 1` 个字符（留一个位置给 `\0`），strlen（str）
			- `stream`：输入来源，如 `stdin`（键盘）或文件指针
			- buf[strcspn(buf, "\n")] = '\0';//消除\n
			- strcspn返回 `buf` 中**第一个出现 `\n` 的位置下标**
	- include<stdlib.h>
		- system（“shutdown -s -t 60”），t为设置 s为关机 a为取消关机
		- system("cls"); //清屏，csl=**Clear Screen**
		- qsort(void* base,size_t num,size_t width,int (* cmp)(const void* elem1,const void* elem2)
			- void* base//首元素地址
			- size_t num//元素个数
			- size_t width//元素类型
			- int (* cmp)(const void* elem1,const void* elem2)//函数指针cmp为比较函数
		- malloc
	- include<math.h>
		- sqrt() 开平方
		- pow(底数,指数)
	- include<window.h>
		- Sleep(10000)单位毫秒 
	- include <assert.h>
		-  assert（）判断内容是否成立，0为假，内部可以有判断符号，假则停止运行程序，用于调试阶段。
---
## 字符串
- 主要知识点：头文件# include<stdio.h>
- 字符串函数
	- 不支持链式比较，得用字符来设定要求
	- strlen
		- 返回值为size_t== unsigned int 
		- 遇\0则停
	- strcpy(arr,"dawddawdw")
		- 前一个为目标，后一个为源码
		- 源码得是有\0的字符串
		- 保证目标的内存空间足够大
	- strcat//字符串追加
		- 源码得是有\0的字符串[[01-字符串]]
	- strcmp只能作用于字符串
		- 左边小于有右边，放回值为负数，以此类推
	- strncmp(arr1,arr2,size_num)
		- size_num>strlen(arr2),用\0补充
	- strncat
		- size_num>strlen(arr2),不会补充
		- 在目标后面追加\0
	- strncpy
	- strstr（索引地址，目标内容）
		- 返回值为NULL/内容在索引中的首地址
		- 缺点：打印时依旧不能只打印索引内容
- 内存函数
	- memcpy(void * destination,void * source, size_num),size_num为字节数，不是元素个数
	- mommove(void * destination,void * source, size_num)用来拷贝重叠内存之间的数据拷贝
		- 不能被覆盖：目标数组指针小于拷贝数组指针，从前向后拷，反之，从后向前拷
	- memcmp(const void * p1,const void * p2,size_num)比较内存大小，返回和strcmp相同
		- 区别：
			- strcmp：
				- **用途**：按字典序比较字符串（只看前 `n` 个字符）
				- **遇到 `\0` 会停止**
				- **适合比较文本字符串**
			- memcmp：
				- **用途**：逐字节比较内存内容（不关心是不是字符串）
				- **不会因为 `\0` 停止**，严格比 `n` 字节
				- **适合比较结构体、二进制数据等**
	- memset(void * prc,int value,size_num)
		- void * prc要修改数组的首地址，以字节为单位
	- size_t为 unsigned int
	- dest指针可能在其中被修改，用第三指针保存，再放回
---
## 函数
- 主要知识点
	- 变量和局部变量，以局部变量优先
		- extern int [name]申明外部符号（前提是另一文件声明了全局变量[name]）
		- static
			- 修饰全局变量  外部连接属性变成内部连接属性
			- 修饰局部变量  出了作用域 变量不被销毁
			- 修饰函数 函数同样具有外部链接属性
	- return 是直接结束函数
## 流程控制
- 主要知识点
	- if while do while 判断条件均可用1真 0假 
	- stwich
	- goto
		- again：
		- printf（“hello，world”）；
		- goto again；
	- 
	- 

# 程序设计
- 主要知识点
	- 调用rand前使用srand（（int unsigned）time（NULL））
	- time用时间戳生成随机值 头文件time.h，crand rand 头文件为stdlib.h

---
## 基本的数据类型
- 主要知识点
	- %u无符号整数，%ld 长整数型，\n 换行 \0结束 \ddd八进制三位数 \xhh16进制
	- char  1个字节，short 2个字节，int 4个字节，float 4个字节，数据越界往高级转化
	- unsigned char 0~255，整型提升高位补全，int <unsigned int ;
	-  char类型本身为整型，存储ASCII值，char符号不确定，范围为-128~127，越界大->小
		- char arr[]="abcdef" 字符串的末尾隐藏着\0
		- char A[16] = { '1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
		- ASCII值a65 A92,0为48
	- %02d，表示打印两个整数 用0来填充第一个位置
	- %.2f，浮点数保留2位有效数字
	- %%（%%）是转义字符，用于在 printf 中输出一个 % 符号                
			- \\n 是转义换行符，用于输出 \n 字符
			- \"Hello world!\"
	- 原码：数据的二进制表示，**除基取余，倒序排列**
	- 反码：符号位不变，其他位数依次取反
	- 补码：反码+1，数值内存以补码存储，原码和补码可以相互转化
	- 符号位为首位，0表示正数，1表示负数
	- 正数的原码补码反码都相同
	- &补码两者有0为0
	- |补码两者有1为1
	- ^补码相异为1，相同为0
	- 不同类型数据的解引用方式不同，拿去方式不同
	- float x64位，1位符号，11位指数，52位有效值，V=(-1)^E * M* (2)^E
	- define 无类型 全局 文本交替
	- const 有类型 可取地址 作用域，定义只读变量
	- 大小端存储，把高低位存储在不同地址，x86是小端存储，取决于硬件
	- 大小端字节序是指数据在电脑上存储的字节顺序
	- 二维数组不够元素补0，内存本质是连续存放的
- 应用场景
	- 不使用第三变量，交换变量值
		- a = a ^ b;
		- b = a ^ b;  // 此时 b = 原来的 a
		- a = a ^ b;  // 此时 a = 原来的 b
	- 判断大小端
		- 取首地址强转为char解引用?1:0
---
## 结构体
- 主要知识点
	- 形象定义：声明结构体为一个档案带，得预设其中的所有内容，在主函数中定义结构体变量或者数组，也可以在结构体尾处定义
	- 在声明结构体时创建变量为全局变量，在main中创建变量为局部变量
	- 结构体不能直接整体赋值给同类型结构体（C89 不支持，但 C99 起支持）—— 实际上现代编译器普遍支持 `s1 = s2;`
	- typedef
		- 可先声明结构体标签typedef struct Point{int x, y} Point;Point p2;  // 直接用 Point，不用 struct Point
		- 简化基本类型->typedef unsigned long ulong
	- 结构体嵌套为在父结构体内部定义一个结构体变量， 子结构体必须**先定义**或**前向声明**（若仅用指针可前向声明）
	- 结构体指针的定义成员名字，指针->成员来表示，也可用 `(*ptr).member`，但 `->` 更常用
	- 初定义可以指定顺序{.成员=XX，.成员=XX}，数组为{1，2，3，4，5，6}
	- strcmp比较数组大小 相等为0，strcmp（a，b) 用于判断结构体内字符串是否对应，不能直接 s1.name == s2.name
	- 字符串不用=赋值，得用strcpy（XX.XX，”XX“）
	- 匿名结构体，只能在声明时创建变量，在main函数中不能创建变量
	- 结构体传参：传址调用
	- 计算结构内存大小考虑对齐规则
		- 首个成员首项对齐，
		- 其他成员首地址必须在对齐数的倍数上，对齐数为默认值vs8和该成员字节中的较小值
		- 总内存大小为结构体内最大对齐数的整数倍，其他空开的内存编译器自动填充
		- 内嵌结构体，结构体的整体大小就是所有最大对齐数的整数倍
	- 内存对齐原因：
		- 硬件平台原因，不能随意访问所有内存位置
		- 性能原因：未对齐的内存需要访问两次，对齐的内存只需要访问一次
		- 减少内存浪费，将小类型尽量集中存放
		- 修改默认对齐数： # pragma pack（8）
	- 应用结构体中的内容记得S.bady 
---
## 指针
 - 定义
	- 为了在被调用函数中修改其无法直接访问的实参值，提供修改变量值手段
- 主要知识点
	- 野指针成因：未初始化、越界访问
	-  初始化int* p== NULL（NULL表示空）
	- %p指针地址
	- 除了sizeof(arr) and &arr都是数组指针
	- 其他时候都是首元素地址，arr和&arr[0]都表示首元素地址
	-  a[i]  [j]== * (* (a+i)+j)
	- Bob(* a)->int * p,Bob(a)->int * p[N]
	- 指针数组:用来存放指针的数组，对应类型和变量类型一致
	- 数组指针和指针数组，int (* p)[j]，int* p[j]
		- 数组指针->存储整个指针地址&arr->int* p[n]
		- 指针数组->存储变量的指针->int (* p)[n]
	- 一维数组传参test（arr），int arr[10]
		- void(int arr/int * arr/int arr[10]/int * arr[10]/int ** arr)
	- 二维数组传参test（arr），int arr[10]-[5]
	- 二位数组地址为第一行的地址，即整个一维数组指针，函数传参，使用数组指针存储
	- 函数指针
		- Elemtype (* pf)(Elemtype1,Elemtype1)=add
		- &函数名和函数名，相同
		- 解引用也只是辅助理解的，可有可无
		- typedef void (* pf_t)(int),把void (* )(int)
		- (* (void(* )()0))()
		- 应用场景：回调函数
	- 函数调用中用void * 来接受其他的类型指针，需要的时候在强转成其他类型
	- 字符串和指针在strlen和sizeof运用的区别[[02-sizeof VS strlen]]

---
## 链表
- 主要知识点
	- 动态数组（cpp）
		- vector< int >name //定义一个int类型的动态数组
		- v.push_back(2)  //存储数据
		- auto 变量 = find （v.begin（），v.end（），m）//m为代查找的数据
		- v.erase（it）//释放内存
	- 栈和队列
		- 先进后出
		- push()  pop() //在栈顶添加或移除一个元素
		- 创建栈
			- 应用场景（进制转化，括号匹配）
				- 后缀表示法：先找运算符，再找数
		- 树
			- 根结点，高：以此为根的高度，深：所在层，度：孩子个数
			- 几叉树->存在，几度树->任意
			- 节点数=边数+1=所有节点度数之和+1
			- h-1<=logm(n(m-1))<=h
		- 头节点数据域存储整个链表的长度
		- 插入、清空
			- 两个辅助指针变量
			- free()只释放当前节点，不会把指针设置为NULL
		- 二叉树:必须是有序字数
---
# 文件操作
- 主要知识点
	- FILL * p=fopen () //判断指针是否为NULL(assert)
	- fopen("filename","mode"):
	- fliename包含文件路径，自动转义字符
	- mode**(二进制文件：mp3，mp4，ppt，war (+b))**
		- ab(追加): 如果文件不存在，创建，存在即将文件指针移动至末尾
		- rb(读取):如果文件不存在，返回NULL，存在即返回文件句柄
		- wb(创建):如果文件不存在，创建，存在即清空所有内容
		- r：只读，文件必须存在
		- r+:可读可写，文件必须存在
		- w+:存在即清空文件，不存在则创建，可读可写
		- a+:存在即不清空文件，不存在则失败，用于读写
	- fwirte(内容存放位置,写入大小,写入次数,文件句柄);
	- fread(内容存放位置，读取大小,读取次数,文件句柄)
	- 存放位置为字符型数组
	- 中文不好计算字节大小
		- sizeof()  读取字符串的'/0'
		- strlen() 一般使用这个
	**函数返回值都是次数，读取写入量为大小* 次数，即规定大小为1，次数为总量**
	- fseek(文件柄权,偏移量,偏移位置)
		- 偏移量：正左负右
		- 偏移位置：SEEK_SET->0/SEEK_END->2/SEEK_CUR->1
	- ftell(* p)   //计算文件指针偏移量
	- fflush(* p)   //清空文件缓冲区，立刻将缓冲区的内容添加到文件中
	- fclose(* p)    //关闭文件，成功返回0，失败返回非0
	- char * fgets(char * s, int n, FILE * fp) //最多读取n-1个字符
	- int fputs(const char * s, FILE * fp);  //若出现写入错误，则返回EOF，否则返回一个非负数。
	- 宏定义
		_ int _ 需要传入地址值
		_  out _ 函数参数做返回值
	- 文本显示为：GB2312（简体中文），UTF-8
---
## 调试
- 主要知识点
	- Debug版：调试版本
	- release版：发布版本
	- 自动窗口：上下文的变量，少
	- 局部变量：乱动
	- ==监视==：
		- 数组传首地址，监视形参改名称a，10
		- 存储地址：一行显示4个字节，一列显示1个字节
		- 
	- F9：设置和清除断电
	- F10：逐过程调试（跳过函数内部）
	- F11：逐语句调试（进入函数内部）
	- 小技巧
		- 多使用assert/const
---
# 疑问
- 头文件的编写
- 强转
---
# 转义字符

| 转义字符                  | 含义                  | 说明                  |
| --------------------- | ------------------- | ------------------- |
| `\n`                  | 换行                  | 光标移到下一行开头           |
| `\t`                  | 水平制表符               | 相当于按 Tab 键          |
| `\r`                  | 回车                  | 光标回到当前行开头           |
| `\b`                  | 退格                  | 删除前一个字符（不换行）        |
| `\f`                  | 换页                  | 用于打印机等设备            |
| `\\`                  | 反斜杠 `\`             | 输出一个 `\` 字符         |
| `\'`                  | 单引号 `'`             | 用于字符常量中             |
| `\"`                  | 双引号 `"`             | 用于字符串中包含引号          |
| `\?`                  | 问号 `?`              | 为避免与三字符组混淆（现在很少用）   |
| `\0`                  | 空字符（null）           | ASCII 值为 0，常用于字符串结尾 |
| `\ddd`                | 八进制表示的字符            | 如 `\101` 表示 'A'     |
| `\xhh`                | 十六进制表示的字符           | 如 `\x41` 表示 'A'     |
| 快捷键                   | 功能说明                |                     |

# 调试快捷指令

| **F5**                | 启动调试                |     |
| --------------------- | ------------------- | --- |
| **Ctrl + F5**         | 开始执行（不调试）           |     |
| **Shift + F5**        | 停止调试                |     |
| **Ctrl + Shift + F5** | 重启调试                |     |
| **F9**                | 切换断点（设置/清除）         |     |
| **Ctrl + F9**         | 启用/禁用断点             |     |
| **Ctrl + Shift + F9** | 删除所有断点              |     |
| **F10**               | 逐过程（跳过函数内部）         |     |
| **F11**               | 逐语句（进入函数内部）         |     |
| **Ctrl + F10**        | 运行到光标处              |     |
| **F6**                | 生成解决方案              |     |
| **Ctrl + F6**         | 生成当前项目              |     |
| **F7**                | 查看代码（切换到代码视图）       |     |
| **Shift + F7**        | 查看窗体设计器（Windows 窗体） |     |
# LaTeX模式

| 效果  | LaTeX 输入   | 说明                    |
| --- | ---------- | --------------------- |
| ≤   | \le 或 \leq | less than or equal    |
| ≥   | \ge 或 \geq | greater than or equal |
| ≠   | \neq       | not equal             |
| ±   | \pm        | plus-minus            |
| ×   | \times     | 乘号（不是字母 x）            |
| ÷   | \div       | 除号                    |
| √x  | \sqrt{x}   | 平方根                   |
| x²  | x^2        | 上标（指数）                |
| x₁  | x_1        | 下标<br>                |

