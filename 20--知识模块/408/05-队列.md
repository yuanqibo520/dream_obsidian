```C
#include<stdio.h>
#define Max_size 10
typedef struct {
	Elemtype data [Max_size];
	int front,rear;
}SqQueue;
void InitSqQueue(SqQueue &Q)
{
	Q.rear=Q.front=0;
}
void test (){
	SqQueue Q;
	InitSqQueue(Q);
}
bool EnQueueQueue(SqQueue &Q,Eletype &x)
{
	if((Q.rear+1)%Max_size=Q.front)//牺牲一个字节使空判定原则相异
	return false;
	Q.data[Q.rear]=x;
	Q.rear=(Q.rear+1)%Max_size;
	return ture;
}
bool DeQueue(SqQueue &Q,Eletype &x)
{
	if(Q.rear==Q.front)
	return false;
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%Max_size;
	return ture;
}
int main()
{
	test();
	int x = 0;
	scanf("%e",x);
	EnQueue(Q,x);
	DeQueue(Q,x)
	return 0;
}
```

```C
#include<stdio.h>
#include<stdlib.h>
typedef struct {
	Elemtype data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	struct LinkNode *front,*rear;
}LinkQueue;
InitLinkQueue(LinkQueue &Q)
{
	Q.rear=Q.front=(LinkNode *)malloc(sizeof(LinkNode));
	Q.rear->next=NULL;
}
void testLinkQueue()
{
	LinkQueue Q
	InitLinkQueue(Q);
}
void EnLinkQueue(LinkQueue &Q,Elemtype x)
{
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;
	s->next=NULL;
	//带头节点
	Q.rear->next=s;
	Q.rear=s;
	//不带头节点
	if(Q.front->next=NULL)
	{
		Q.front=Q.rear=s;
	}
	else
	{
		Q.rear->next=s;
		Q.rear=s;
	}
}
void DeQueue(LinkQueue &Q,Elemtype &x)
{
	if(Q.rear==Q.front)//带头节点
		return false;
	LinkNode *s=Q.front->next;
	x=s->data;
	Q.front->next=s->next;
	if(Q.rear==s)
	Q.rear=Q.front;
	if(Q.front==NULL)//不带头节点
	return false;
	LinkNode *s=Q.front->next;
	x=s->data;
	Q.front->next=s->next;
	if(Q.rear==s)
	Q.rear=NULL;
	Q.front=NULL;
	free(s);
	return 0;
}
int main()
{
	testLinkQueue();
	Elemtype x;
	scanf("%e",x);
	DeQueue(Q,x);
	EnLinkQueue(Q,x);
	return 0;
}
```