```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX 100  // 栈的最大容量

//创建操作数栈和运算符栈
typedef struct {
    double data[MAX];
    int top;
} StackNum;
typedef struct {
    char data[MAX];
    int top;
} StackOp;
//初始化，不同函数中指针变量不同，虽同为结构体指针
void InitNum(StackNum* s) {
    s->top = -1;
}
void InitOp(StackOp* s) {
    s->top = -1;
}
//判断是否为‘ ’
bool is_space(char n)
{
    if (n == ' ')
        return true;
    else
        return false;
}
//判断是否为数字
bool is_digit(char n)
{
    switch (n)
    {
	    case '0':return true;
	    case '1':return true;
	    case '2':return true;
	    case '3':return true;
	    case '4':return true;
	    case '5':return true;
	    case '6':return true;
        case '7':return true;
        case '8':return true;
        case '9':return true;
	    default:return false;
    }
}
// 判断操作数栈是否为空
int isEmptyNum(StackNum* s) {
    return s->top == -1;
}
int isEmptyOp(StackOp* s) {
    return s->top == -1;
}
// 从栈弹出一个数值
double popNum(StackNum* s) {
    return s->data[(s->top)--];
}
double popOp(StackOp* s)
{
    return s->data[(s->top)--];
}
// 将运算符压入运算符栈
void pushOp(StackOp* s, char op) {
    s->data[++(s->top)] = op;
}
// 将数值压入操作数栈
void pushNum(StackNum* s, double val) {
    s->data[++(s->top)] = val;
}
// 查看运算符栈顶元素（不弹出）
char peekOp(StackOp* s) {
    return s->data[s->top];
}
// 返回运算符的优先级：+ - 为1，* / 为2，其他（如 '('）为0
int precedence(char op) {
    switch (op) {
    case '+':
    case '-': return 1;
    case '*':
    case '/': return 2;
    default:  return 0;  // 用于 '(' 等非运算符
    }
}
// 根据运算符对两个操作数进行计算
double applyOp(double a, double b, char op) {
    if (b == 0)
        return 0;
    switch (op) {
    case '+': return a + b;
    case '-': return a - b;
    case '*': return a * b;
    case '/': return a / b;  // 注意：未检查除零
    default:  return 0;
    }
}
// 主函数：计算中缀表达式的值
double evaluate(const char* expr) {
    StackNum nums;
    StackOp ops;
    InitOp(&ops);
    InitNum(&nums);
    // 遍历表达式中的每个字符
    for (int i = 0; expr[i] != '\0'; i++) {
        char c = expr[i];
        // 跳过空格
        if (is_space(c)) continue;
        // 如果是数字或小数点，解析整个数字（支持小数）
        if (is_digit(c) || c == '.')
        {
            double val = 0.0;
            // 解析整数部分
            while (is_digit(expr[i])) {
                val = val * 10 + (expr[i] - '0');//数字为ASCII值，通过-0为正常值
                i++;
            }
            // 如果遇到小数点，继续解析小数部分
            if (expr[i] == '.') {
                i++;  // 跳过 '.'
                double frac = 0.1;
                while (is_digit(expr[i])) {
                    val += (expr[i] - '0') * frac;
                    frac /= 10;
                    i++;
                }
            }
            i--;  // 手动移动到了最新位置，for循环结束后i++，需要回退一步
            pushNum(&nums, val);
        }
        // 遇到左括号，直接入栈
        else if (c == '(') {
            pushOp(&ops, c);
        }
        // 遇到右括号，持续计算直到遇到左括号
        else if (c == ')') {
            while (!isEmptyOp(&ops) && peekOp(&ops) != '(')
            {
                double b = popNum(&nums);
                double a = popNum(&nums);
                char op = popOp(&ops);
                pushNum(&nums, applyOp(a, b, op));
            }
            // 弹出左括号 '('
            popOp(&ops);
        }
        // 如果是运算符 (+, -, *, /)
        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            // 当运算符栈非空，且栈顶不是 '('，且栈顶运算符优先级 >= 当前运算符
            while (!isEmptyOp(&ops) && peekOp(&ops) != '(' &&
                precedence(peekOp(&ops)) >= precedence(c))
            {
                // 弹出两个操作数和一个运算符，计算后压回结果
                double b = popNum(&nums);
                double a = popNum(&nums);
                char op = popOp(&ops);
                pushNum(&nums, applyOp(a, b, op));
            }
            // 当前运算符入栈
            pushOp(&ops, c);
        }
    }
    // 表达式扫描完毕，处理栈中剩余的运算符
    while (!isEmptyOp(&ops)) {
        double b = popNum(&nums);
        double a = popNum(&nums);
        char op = popOp(&ops);
        pushNum(&nums, applyOp(a, b, op));
    }
    // 最终结果在操作数栈顶
    return popNum(&nums);
}
// 主程序：读取用户输入并输出计算结果
int main() {
    char expr[256] = { 0 };
    printf("请输入中缀表达式: ");
    fgets(expr, sizeof(expr), stdin);  // 安全读取一行
    expr[strcspn(expr, "\n")] = '\0';  // 去掉换行符
    double result = evaluate(expr);
    printf("结果: %.5f\n", result);
    return 0;
}

//流程图
开始
│
├─ 初始化：定义 StackNum 和 StackOp 结构体
│
└─ main() 函数
│
├─ 提示用户输入表达式
├─ 读取一行字符串 expr（使用 fgets）
├─ 去除换行符
│
└─ 调用 evaluate(expr)
│
├─ 创建并初始化两个栈：nums（操作数）、ops（运算符）
│
├─ 从左到右遍历 expr 的每个字符 c
│   │
│   ├─ 若 c 是空格 → 跳过
│   │
│   ├─ 若 c 是数字或 '.'
│   │     ├─ 解析完整数字（整数 + 小数部分）
│   │     └─ 将数值压入 nums 栈
│   │
│   ├─ 若 c == '('
│   │     └─ 压入 ops 栈
│   │
│   ├─ 若 c == ')'
│   │     ├─ 循环：只要 ops 栈顶不是 '('
│   │     │     ├─ 弹出两个操作数 a, b 和一个运算符 op
│   │     │     ├─ 计算 applyOp(a, b, op)
│   │     │     └─ 结果压回 nums
│   │     └─ 弹出 '('（不参与计算）
│   │
│   └─ 若 c 是 + , -, *, /
│         ├─ 循环：只要 ops 非空、栈顶不是 '('、且栈顶运算符优先级 ≥ 当前 c
│         │     ├─ 弹出 a, b, op
│         │     ├─ 计算并压回结果
│         │     └─ 继续检查新栈顶
│         └─ 将 c 压入 ops 栈
│
├─ 表达式结束，处理 ops 栈中剩余运算符
│     ├─ 重复弹出 a, b, op → 计算 → 压回
│     └─ 直到 ops 为空
│
└─ 返回 nums 栈中唯一剩下的值（即结果）
│
└─ 回到 main()
│
└─ 打印结果（保留两位小数）
│
└─ 程序结束


```
